Here are the algorithms presented in the specified pseudocode format:

**1. LINEAR_SEARCH(A, N, VAL)**
   // A: Array, N: Size of Array, VAL: Value to search

Step 1: [INITIALIZE] SET I = 0, POS = -1
Step 2: Repeat Step 3 while I < N
Step 3:   IF A[I] = VAL
            SET POS = I
            Go to Step 4
          [END OF IF]
          SET I = I + 1
        [END OF LOOP]
Step 4: IF POS = -1
          PRINT "VALUE IS NOT PRESENT IN THE ARRAY"
        ELSE
          PRINT "VALUE FOUND AT INDEX: ", POS
        [END OF IF]
Step 5: EXIT

**2. BINARY_SEARCH(A, LB, UB, VAL)**
   // A: Sorted Array, LB: Lower Bound index, UB: Upper Bound index, VAL: Value to search

Step 1: [INITIALIZE] SET BEG = LB, END = UB, POS = -1
Step 2: Repeat Steps 3 and 4 while BEG <= END
Step 3:   SET MID = (BEG + END) / 2
Step 4:   IF A[MID] = VAL
            SET POS = MID
            Go to Step 6
          ELSE IF A[MID] > VAL
            SET END = MID - 1
          ELSE
            SET BEG = MID + 1
          [END OF IF]
        [END OF LOOP]
Step 5: IF POS = -1
          PRINT "VALUE IS NOT PRESENT IN THE ARRAY"
        [END OF IF]
Step 6: EXIT // If found, POS holds the index

**3. BUBBLE_SORT(A, N)**
   // A: Array, N: Size of Array

Step 1: [INITIALIZE] SET I = 0
Step 2: Repeat Steps 3 to 6 while I < N - 1
Step 3:   [INITIALIZE] SET J = 0, SWAPPED = FALSE
Step 4:   Repeat Step 5 while J < N - I - 1
Step 5:     IF A[J] > A[J + 1]
              SWAP A[J], A[J + 1]
              SET SWAPPED = TRUE
            [END OF IF]
            SET J = J + 1
          [END OF LOOP]
Step 6:   IF SWAPPED = FALSE
            Go to Step 8 // Array is sorted
          [END OF IF]
          SET I = I + 1
        [END OF LOOP]
Step 7: PRINT "ARRAY SORTED" // Or just finish
Step 8: EXIT

**4. INSERTION_SORT_DESCENDING(A, N)**
   // A: Array, N: Size of Array

Step 1: [INITIALIZE] SET I = 1
Step 2: Repeat Steps 3 to 6 while I < N
Step 3:   SET KEY = A[I]
Step 4:   SET J = I - 1
Step 5:   Repeat Step 6 while J >= 0 AND A[J] < KEY
Step 6:     SET A[J + 1] = A[J]
            SET J = J - 1
          [END OF LOOP]
Step 7:   SET A[J + 1] = KEY
Step 8:   SET I = I + 1
        [END OF LOOP]
Step 9: PRINT "ARRAY SORTED IN DESCENDING ORDER"
Step 10: EXIT

**5. SELECTION_SORT(A, N)**
    // A: Array, N: Size of Array

Step 1: [INITIALIZE] SET I = 0
Step 2: Repeat Steps 3 to 6 while I < N - 1
Step 3:   [FIND MINIMUM] SET MIN_IDX = I
Step 4:   SET J = I + 1
Step 5:   Repeat Step 6 while J < N
Step 6:     IF A[J] < A[MIN_IDX]
              SET MIN_IDX = J
            [END OF IF]
            SET J = J + 1
          [END OF LOOP]
Step 7:   [SWAP] IF MIN_IDX != I
             SWAP A[I], A[MIN_IDX]
           [END OF IF]
Step 8:   SET I = I + 1
        [END OF LOOP]
Step 9: PRINT "ARRAY SORTED"
Step 10: EXIT

**6. STACK_ARRAY_PUSH_POP(ARR, MAX_SIZE)**
   // ARR: Array for stack, MAX_SIZE: Max capacity
   // Internal variable: TOP (initially -1)

* **PUSH(VALUE):**
    Step 1: IF TOP = MAX_SIZE - 1
              PRINT "STACK OVERFLOW"
              EXIT
            [END OF IF]
    Step 2: SET TOP = TOP + 1
    Step 3: SET ARR[TOP] = VALUE
    Step 4: EXIT

* **POP():**
    Step 1: IF TOP = -1
              PRINT "STACK UNDERFLOW"
              RETURN ERROR // Or handle appropriately
            [END OF IF]
    Step 2: SET POPPED_VALUE = ARR[TOP]
    Step 3: SET TOP = TOP - 1
    Step 4: RETURN POPPED_VALUE
    Step 5: EXIT

**7. STACK_ARRAY_PEEK_DISPLAY(ARR, MAX_SIZE)**
   // ARR: Array for stack, MAX_SIZE: Max capacity
   // Internal variable: TOP (initially -1)

* **PEEK():**
    Step 1: IF TOP = -1
              PRINT "STACK EMPTY"
              RETURN ERROR // Or handle appropriately
            [END OF IF]
    Step 2: RETURN ARR[TOP]
    Step 3: EXIT

* **DISPLAY():**
    Step 1: IF TOP = -1
              PRINT "STACK IS EMPTY"
              EXIT
            [END OF IF]
    Step 2: PRINT "STACK ELEMENTS (TOP TO BOTTOM):"
    Step 3: SET I = TOP
    Step 4: Repeat Step 5 while I >= 0
    Step 5:   PRINT ARR[I]
            SET I = I - 1
          [END OF LOOP]
    Step 6: EXIT

**8. LINEAR_QUEUE_ARRAY_ENQUEUE_DEQUEUE(ARR, MAX_QUEUE_SIZE)**
   // ARR: Array for queue, MAX_QUEUE_SIZE: Max capacity
   // Internal variables: FRONT, REAR (initially -1)

* **ENQUEUE(VALUE):**
    Step 1: IF REAR = MAX_QUEUE_SIZE - 1
              PRINT "QUEUE OVERFLOW"
              EXIT
            [END OF IF]
    Step 2: IF FRONT = -1
              SET FRONT = 0
            [END OF IF]
    Step 3: SET REAR = REAR + 1
    Step 4: SET ARR[REAR] = VALUE
    Step 5: EXIT

* **DEQUEUE():**
    Step 1: IF FRONT = -1 OR FRONT > REAR
              PRINT "QUEUE UNDERFLOW"
              RETURN ERROR // Or handle appropriately
            [END OF IF]
    Step 2: SET DEQUEUED_VALUE = ARR[FRONT]
    Step 3: SET FRONT = FRONT + 1
    Step 4: IF FRONT > REAR // Optional Reset
              SET FRONT = -1
              SET REAR = -1
            [END OF IF]
    Step 5: RETURN DEQUEUED_VALUE
    Step 6: EXIT

**9. LINEAR_QUEUE_ARRAY_DEQUEUE_DISPLAY(ARR, MAX_QUEUE_SIZE)**
   // ARR: Array for queue, MAX_QUEUE_SIZE: Max capacity
   // Internal variables: FRONT, REAR (initially -1)

* **DEQUEUE():** // Same as Step 8's DEQUEUE
    Step 1: IF FRONT = -1 OR FRONT > REAR
              PRINT "QUEUE UNDERFLOW"
              RETURN ERROR
            [END OF IF]
    Step 2: SET DEQUEUED_VALUE = ARR[FRONT]
    Step 3: SET FRONT = FRONT + 1
    Step 4: IF FRONT > REAR
              SET FRONT = -1
              SET REAR = -1
            [END OF IF]
    Step 5: RETURN DEQUEUED_VALUE
    Step 6: EXIT

* **DISPLAY():**
    Step 1: IF FRONT = -1 OR FRONT > REAR
              PRINT "QUEUE IS EMPTY"
              EXIT
            [END OF IF]
    Step 2: PRINT "QUEUE ELEMENTS (FRONT TO REAR):"
    Step 3: SET I = FRONT
    Step 4: Repeat Step 5 while I <= REAR
    Step 5:   PRINT ARR[I]
            SET I = I + 1
          [END OF LOOP]
    Step 6: EXIT

**10. CIRCULAR_QUEUE_ARRAY_ENQUEUE_DISPLAY(ARR, CQUEUE_SIZE)**
    // ARR: Array for queue, CQUEUE_SIZE: Capacity
    // Internal variables: FRONT, REAR (initially -1), COUNT (initially 0)

* **ENQUEUE(VALUE):**
    Step 1: IF COUNT = CQUEUE_SIZE
              PRINT "QUEUE OVERFLOW"
              EXIT
            [END OF IF]
    Step 2: IF FRONT = -1
              SET FRONT = 0
            [END OF IF]
    Step 3: SET REAR = (REAR + 1) MOD CQUEUE_SIZE
    Step 4: SET ARR[REAR] = VALUE
    Step 5: SET COUNT = COUNT + 1
    Step 6: EXIT

* **DISPLAY():**
    Step 1: IF COUNT = 0
              PRINT "QUEUE IS EMPTY"
              EXIT
            [END OF IF]
    Step 2: PRINT "QUEUE ELEMENTS (FRONT TO REAR):"
    Step 3: SET I = FRONT
    Step 4: SET DISPLAYED_COUNT = 0
    Step 5: Repeat Step 6 while DISPLAYED_COUNT < COUNT
    Step 6:   PRINT ARR[I]
            SET I = (I + 1) MOD CQUEUE_SIZE
            SET DISPLAYED_COUNT = DISPLAYED_COUNT + 1
          [END OF LOOP]
    Step 7: EXIT

**11. CIRCULAR_QUEUE_ARRAY_DEQUEUE_DISPLAY(ARR, CQUEUE_SIZE)**
    // ARR: Array for queue, CQUEUE_SIZE: Capacity
    // Internal variables: FRONT, REAR (initially -1), COUNT (initially 0)

* **DEQUEUE():**
    Step 1: IF COUNT = 0
              PRINT "QUEUE UNDERFLOW"
              RETURN ERROR
            [END OF IF]
    Step 2: SET DEQUEUED_VALUE = ARR[FRONT]
    Step 3: SET COUNT = COUNT - 1
    Step 4: IF COUNT = 0
              SET FRONT = -1
              SET REAR = -1
            ELSE
              SET FRONT = (FRONT + 1) MOD CQUEUE_SIZE
            [END OF IF]
    Step 5: RETURN DEQUEUED_VALUE
    Step 6: EXIT

* **DISPLAY():** // Same as Step 10's DISPLAY
    Step 1: IF COUNT = 0
              PRINT "QUEUE IS EMPTY"
              EXIT
            [END OF IF]
    Step 2: PRINT "QUEUE ELEMENTS (FRONT TO REAR):"
    Step 3: SET I = FRONT
    Step 4: SET DISPLAYED_COUNT = 0
    Step 5: Repeat Step 6 while DISPLAYED_COUNT < COUNT
    Step 6:   PRINT ARR[I]
            SET I = (I + 1) MOD CQUEUE_SIZE
            SET DISPLAYED_COUNT = DISPLAYED_COUNT + 1
          [END OF LOOP]
    Step 7: EXIT

**12. DEQUE_ARRAY_ENQUEUE_FRONT_DISPLAY(ARR, DEQUE_SIZE)**
    // ARR: Array for deque, DEQUE_SIZE: Capacity
    // Internal variables: FRONT, REAR (initially -1), COUNT (initially 0)

* **ENQUEUE_FRONT(VALUE):**
    Step 1: IF COUNT = DEQUE_SIZE
              PRINT "DEQUE OVERFLOW"
              EXIT
            [END OF IF]
    Step 2: IF FRONT = -1 // Deque is empty
              SET FRONT = 0
              SET REAR = 0
            ELSE IF FRONT = 0 // Wrap around
              SET FRONT = DEQUE_SIZE - 1
            ELSE // Normal case
              SET FRONT = FRONT - 1
            [END OF IF]
    Step 3: SET ARR[FRONT] = VALUE
    Step 4: SET COUNT = COUNT + 1
    Step 5: EXIT

* **DISPLAY():**
    Step 1: IF COUNT = 0
              PRINT "DEQUE IS EMPTY"
              EXIT
            [END OF IF]
    Step 2: PRINT "DEQUE ELEMENTS (FRONT TO REAR):"
    Step 3: SET I = FRONT
    Step 4: SET DISPLAYED_COUNT = 0
    Step 5: Repeat Step 6 while DISPLAYED_COUNT < COUNT
    Step 6:   PRINT ARR[I]
            SET I = (I + 1) MOD DEQUE_SIZE
            SET DISPLAYED_COUNT = DISPLAYED_COUNT + 1
          [END OF LOOP]
    Step 7: EXIT

**13. SLL_INSERT_POSITION(HEAD, DATA, POSITION)**
    // HEAD: Pointer to the first node, DATA: Value to insert, POSITION: 1-based index

Step 1: ALLOCATE NEW_NODE
Step 2: SET NEW_NODE.DATA = DATA, NEW_NODE.NEXT = NULL
Step 3: IF POSITION <= 0
          PRINT "INVALID POSITION"
          FREE NEW_NODE // Clean up
          EXIT
        [END OF IF]
Step 4: IF POSITION = 1
          SET NEW_NODE.NEXT = HEAD
          SET HEAD = NEW_NODE
          EXIT
        [END OF IF]
Step 5: [TRAVERSE] SET TEMP = HEAD, CURRENT_POS = 1
Step 6: Repeat Step 7 while TEMP != NULL AND CURRENT_POS < POSITION - 1
Step 7:   SET TEMP = TEMP.NEXT
          SET CURRENT_POS = CURRENT_POS + 1
        [END OF LOOP]
Step 8: IF TEMP = NULL // Position out of bounds
          PRINT "POSITION OUT OF BOUNDS"
          FREE NEW_NODE // Clean up
          EXIT
        [END OF IF]
Step 9: SET NEW_NODE.NEXT = TEMP.NEXT
Step 10: SET TEMP.NEXT = NEW_NODE
Step 11: EXIT

**14. SLL_INSERT_END(HEAD, DATA)**
    // HEAD: Pointer to the first node, DATA: Value to insert

Step 1: ALLOCATE NEW_NODE
Step 2: SET NEW_NODE.DATA = DATA, NEW_NODE.NEXT = NULL
Step 3: IF HEAD = NULL
          SET HEAD = NEW_NODE
          EXIT
        [END OF IF]
Step 4: [TRAVERSE] SET TEMP = HEAD
Step 5: Repeat Step 6 while TEMP.NEXT != NULL
Step 6:   SET TEMP = TEMP.NEXT
        [END OF LOOP]
Step 7: SET TEMP.NEXT = NEW_NODE
Step 8: EXIT

**15. CLL_INSERT_BEGINNING(LAST, DATA)**
    // LAST: Pointer to the last node, DATA: Value to insert

Step 1: ALLOCATE NEW_NODE
Step 2: SET NEW_NODE.DATA = DATA
Step 3: IF LAST = NULL // List is empty
          SET LAST = NEW_NODE
          SET NEW_NODE.NEXT = NEW_NODE // Points to itself
        ELSE // List is not empty
          SET NEW_NODE.NEXT = LAST.NEXT // New node points to current head
          SET LAST.NEXT = NEW_NODE // Last node points to new head
        [END OF IF]
Step 4: EXIT

**16. CLL_INSERT_END(LAST, DATA)**
    // LAST: Pointer to the last node, DATA: Value to insert

Step 1: ALLOCATE NEW_NODE
Step 2: SET NEW_NODE.DATA = DATA
Step 3: IF LAST = NULL // List is empty
          SET LAST = NEW_NODE
          SET NEW_NODE.NEXT = NEW_NODE
        ELSE // List is not empty
          SET NEW_NODE.NEXT = LAST.NEXT // New node points to head
          SET LAST.NEXT = NEW_NODE // Current last points to new node
          SET LAST = NEW_NODE // Update LAST pointer
        [END OF IF]
Step 4: EXIT

**17. STACK_LL_PUSH_POP(TOP)**
    // TOP: Pointer to the top node (head of list)

* **PUSH(VALUE):**
    Step 1: ALLOCATE NEW_NODE
    Step 2: SET NEW_NODE.DATA = VALUE
    Step 3: SET NEW_NODE.NEXT = TOP
    Step 4: SET TOP = NEW_NODE
    Step 5: EXIT

* **POP():**
    Step 1: IF TOP = NULL
              PRINT "STACK UNDERFLOW"
              RETURN ERROR
            [END OF IF]
    Step 2: SET TEMP = TOP
    Step 3: SET POPPED_VALUE = TOP.DATA
    Step 4: SET TOP = TOP.NEXT
    Step 5: FREE TEMP // Deallocate memory
    Step 6: RETURN POPPED_VALUE
    Step 7: EXIT

**18. DLL_INSERT_END(HEAD, TAIL, DATA)**
    // HEAD: Pointer to first node, TAIL: Pointer to last node, DATA: Value

Step 1: ALLOCATE NEW_NODE
Step 2: SET NEW_NODE.DATA = DATA, NEW_NODE.PREV = NULL, NEW_NODE.NEXT = NULL
Step 3: IF HEAD = NULL // List is empty
          SET HEAD = NEW_NODE
          SET TAIL = NEW_NODE
        ELSE // List is not empty
          SET TAIL.NEXT = NEW_NODE
          SET NEW_NODE.PREV = TAIL
          SET TAIL = NEW_NODE // Update TAIL
        [END OF IF]
Step 4: EXIT

**19. BST_INSERT_INORDER(ROOT)**
    // ROOT: Pointer to the root node

* **INSERT(DATA):**
    Step 1: SET ROOT = INSERT_RECURSIVE(ROOT, DATA)
    Step 2: EXIT

* **INSERT_RECURSIVE(NODE, DATA):**
    Step 1: IF NODE = NULL
              ALLOCATE NEW_NODE
              SET NEW_NODE.DATA = DATA, NEW_NODE.LEFT = NULL, NEW_NODE.RIGHT = NULL
              RETURN NEW_NODE
            [END OF IF]
    Step 2: IF DATA < NODE.DATA
              SET NODE.LEFT = INSERT_RECURSIVE(NODE.LEFT, DATA)
            ELSE IF DATA > NODE.DATA
              SET NODE.RIGHT = INSERT_RECURSIVE(NODE.RIGHT, DATA)
            // ELSE: Ignore duplicate or handle as needed
            [END OF IF]
    Step 3: RETURN NODE

* **INORDER_TRAVERSAL():**
    Step 1: CALL INORDER_RECURSIVE(ROOT)
    Step 2: EXIT

* **INORDER_RECURSIVE(NODE):**
    Step 1: IF NODE != NULL
              CALL INORDER_RECURSIVE(NODE.LEFT)
              PRINT NODE.DATA
              CALL INORDER_RECURSIVE(NODE.RIGHT)
            [END OF IF]
    Step 2: EXIT

**20. GRAPH_ADJ_MATRIX(NUM_VERTICES)**
    // NUM_VERTICES: Number of vertices
    // Internal: ADJ_MATRIX (2D Array)

* **INITIALIZE(VERTICES):**
    Step 1: SET NUM_VERTICES = VERTICES
    Step 2: CREATE ADJ_MATRIX[NUM_VERTICES][NUM_VERTICES]
    Step 3: SET I = 0
    Step 4: Repeat Step 5 while I < NUM_VERTICES
    Step 5:   SET J = 0
    Step 6:   Repeat Step 7 while J < NUM_VERTICES
    Step 7:     SET ADJ_MATRIX[I][J] = 0
              SET J = J + 1
            [END OF LOOP]
            SET I = I + 1
          [END OF LOOP]
    Step 8: EXIT

* **ADD_EDGE(SRC, DEST):** // Undirected
    Step 1: IF SRC >= 0 AND SRC < NUM_VERTICES AND DEST >= 0 AND DEST < NUM_VERTICES
              SET ADJ_MATRIX[SRC][DEST] = 1
              SET ADJ_MATRIX[DEST][SRC] = 1
            ELSE
              PRINT "INVALID VERTEX"
            [END OF IF]
    Step 2: EXIT

* **ADD_DIRECTED_EDGE(SRC, DEST):** // Directed
    Step 1: IF SRC >= 0 AND SRC < NUM_VERTICES AND DEST >= 0 AND DEST < NUM_VERTICES
              SET ADJ_MATRIX[SRC][DEST] = 1
            ELSE
              PRINT "INVALID VERTEX"
            [END OF IF]
    Step 2: EXIT

* **PRINT_ADJ_MATRIX():**
    Step 1: SET I = 0
    Step 2: Repeat Steps 3 to 7 while I < NUM_VERTICES
    Step 3:   SET J = 0
    Step 4:   Repeat Step 5 while J < NUM_VERTICES
    Step 5:     PRINT ADJ_MATRIX[I][J]
              SET J = J + 1
            [END OF LOOP]
    Step 6:   PRINT NEWLINE // Move to next row
    Step 7:   SET I = I + 1
          [END OF LOOP]
    Step 8: EXIT

